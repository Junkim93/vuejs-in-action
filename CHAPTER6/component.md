# 컴포넌트 사용

## 이 장에서 잘 알고 넘어가야 할 것

- 컴포넌트 부모와 자식의 이해 관계
- 지역과 전역 컴포넌트 등록
- 속성과 속성 검증 사용
- 사용자 지정 이벤트 추가

코드가 길어질수록 특정 정보를 찾기 힘들어지기 때문에, 코드를 분리해야 한다. 분리한 코드는 하나의 컴포넌트가 되는데, 컴포넌트는 재활용성이 있어야 하고, 속성과 이벤트를 넘겨줄 수 있어야 한다

## 컴포넌트란

- 코드를 작은 논리적 부분으로 분리한다
- 단일 요소를 이용해서 접근할 수 있도록 한다

```js
<div>
  <ul>
    <p>컴포넌트 예</p>
  </ul>
</div>

// 아래 처럼 단일 요소로 치환한다

<my-component></my-component>
```

### 컴포넌트 생성

- 전역 등록과 지역 등록 두 가지가 있다
  - 전역 컴포넌트는 애플리케이션 전체에서 사용 가능하다
  - 지역 컴포넌트는 컴포넌트가 생성된 Vue.js 인스턴스 내에서만 사용 가능하다
- 모든 컴포넌트 이름은 붙임표를 포함한 소문자로 하는 것이 좋다
  - (아래의 설명은 SFC에서만 유효하다. SFC가 아닌 경우는 케밥케이스를 사용해야 한다)
    - 케밥케이스를 권하지만, cli도 그렇고 파스칼케이스를 사용하는 경우를 더 많이봤다
    - 그냥 팀이 더 선호하는 것을 사용하는 게 좋다고 생각한다. 개인적으로는 파스칼케이스가 컴포넌트임을 좀 더 명시적으로 드러낸다고 생각한다

### 전역 등록

- 템플릿: HTML이 있는 곳. 모든 템플릿은 태그로 감싸야 한다
- 작성한 컴포넌트는 부모 템플릿에 추가해야 한다

```js
Vue.component('my-component', {
  template: '<div>~~~</div>'
})
```
위와 같은 형식으로 전역에 컴포넌트를 등록할 수 있다.

조금 이상하지만 이런 방법도 가능하다

``` js
<div>
  <table>
    <tr is="my-row"></tr>
  </table>
</div>
```
tr 태그가 my-row 컴포넌트와 연결된다

### 지역 등록

- Vue 인스턴스 하나로 범위를 제한한다
- 등록한 Vue 인스턴스만 해당 컴포넌트에 접근 가능하다

```js
const Component = {
  template: '<div>안녕, 지역 컴포넌트로부터</div>'
}

new Vue({
  el: '#app',
  components: { 'my-component': Component }
})
```
app이라는 아이디를 가진 인스턴스만 my-component라는 컴포넌트에 접근할 수 있다

- 컴포넌트의 이름은 my-component이고, Component는 해당 컴포넌트의 값을 담은 상수이다
- 컴포넌트 이름은 케밥케이스로 작성해야 된다
  - HTML 템플릿이 케밥 케이스여야 하기 때문인데, 속성 값에도 마찬가지로 적용된다

## 컴포넌트 관계

- 요구사항의 변화에 따라 코드를 유연하게 관리할 수 있어야 한다
  - 기능을 담당하는 부분을 컴포넌트로 분리한다
  - 부모에서 데이터를 받아오고 자식 컴포넌트에 필요한 데이터를 전달한다
  - 이런 관점에서 부모 컴포넌트의 역할이 명확해야 한다
    - 어떤 역할이고 해당 역할을 수행하기 위해 어떻게 구성되어야 할지 인지하면서 작업한다
- 각 컴포넌트는 분리되어 있어, 부모 데이터나 자식 데이터에 직접 접근할 수 없다
  - 이런 관점에서 props라는 개념이 등장한다
  - props는 부모 컴포넌트에서 자식 컴포넌트로 전달된 데이터를 의미한다
  - 자식 컴포넌트에서 props라는 이름을 명시하고, 전달된 속성에 대해 표현한다
  - 속성은 부모 컴포넌트에서 자식 컴포넌트로 단반향이다
    - 실수로 자식이 부모 상태를 바꾸는 것을 방지한다 (모든 변경은 부모에서 이루어져야 한다)

## 속성을 사용한 데이터 전달

- 속성은 부모에서 자식 컴포넌트로 데이터를 전달할 때 사용한다
  - 부모에서 자식으로의 단방향만 제공한다
  - 유효성 검사가 가능하다 (들어온 값이 어떤 형태인지 확인할 수 있다)

### 리터럴 속성

- 단순 문자열을 전달하는 방식이다

```js
<div id="app">
  <my-component text="World"></my-component>
</div>
```
World라는 문자 리터럴을 my-component라는 자식 컴포넌트에 전달한다

### 동적 속성

- 변경될 수 있는 속성이다
  - 기본적으로는 부모 컴포넌트에서 정의된 데이터 값을 바인딩해서 사용하는 경우를 의미한다
  - v-bind 지시자를 이용해서 전달할 수 있다

- `dynamic-props-counter.html`을 참고하자

### 속성 검증

부모에게 받은 속성의 유효성 검증이 가능하다

1. 타입 체크
   1. 문자열(String)
   2. 숫자(Number)
   3. 불(Boolean)
   4. 함수(Function)
   5. 객체(Object)
   6. 배열(Array)
   7. 기호(Symbol)

- 타입의 필수 여부와 기본값을 추가할 수 있다
  - 필수여부: required
  - 기본값: default
    - 속성에 아무 값도 전달되지 않았을 경우에 할당할 값을 의미한다
  - 속성 타입이 객체라면 반드시 기본값이 할당되어야 한다

### 템플릿 컴포넌트 정의

- 전역, 지역 등록은 템플릿 구문 써주는 게 너무 복잡하다
  - 여러 줄로 작성하려면 이스케이프 문자도 추가해줘야 한다

### 인라인 템플릿 문자열 사용

- 이 방법도 결국 컴포넌트의 정보가 많아지면 보기 힘들어진다

### text/x-template 스크립트 요소

- `type="text/x-template"`으로 스크립트를 정의하는 방법이 있다
- 이 방법도 하나의 파일 안에 전부 정해지므로, 규모가 커질수록 복잡해진다

### 단일 파일 컴포넌트

- 실질적으로 프로젝트에서 사용되는 형태
- 컴포넌트라는 의미에 적합하게 각각의 부분을 별도로 분리할 수 있다
- 별도로 분리되는 파일은 `.vue` 확장자를 가지기 때문에, 웹팩 등의 빌드 도구를 사용해야만 한다

## 커스텀 이벤트

- 이벤트 인터페이스가 있다
  - $on(이벤트 이름) -> 이벤트를 수신한다
    - 부모 자식 관계가 아닌 컴포넌트 간에 이벤트를 송신할 때 사용한다
    - 부모 자식 관계가 아닌데 서로 상태를 주고받는 것은, 애플리케이션 복잡도가 높아짐에 따라 의도하지 않은 부수효과를 발생시킬 확률을 높인다
    - 차라리 Vuex를 사용하여, 단일 경로를 통해 데이터를 주고 받는 것이 좋아보인다
  - $emit(이벤트 이름) -> 이벤트를 트리거한다

### 이벤트 수신

- 자식 컴포넌트에서 이벤트가 일어났음을 알려주고, 부모 컴포넌트에서 데이터를 변경시킨다
- `event-listen.html` 파일을 보자

### .sync 사용해서 자식 속성 변경

- `.sync` 변경자는 아래 코드의 syntax sugar다

```html
<my-component
  :my-counter="counter"
  @update:my-counter="val => bar = val"
></my-component>
```

- 이것도 `event-listen-sync.html`을 보자